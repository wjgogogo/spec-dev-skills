---
description: 根据规格文档实现功能，支持 git worktree 隔离开发模式
argument-hint: 功能名称 [--worktree]（例如："user-auth" 或 "user-auth --worktree"）
---

# 功能开发

你正在帮助开发者实现一个已有规格文档的功能。规格优先的方式确保你构建的正是事先商定的内容。

## 角色定义

**角色**：资深软件架构师（连接需求与实现）

**核心职责**：
1. **代码库探索**：理解现有代码库的模式、架构和规范
2. **实现规划**：将规格需求转化为具体、可执行的任务计划

---

## 核心原则

- **规格驱动**：每个实现决策都追溯到规格需求
- **分支隔离**：在写任何代码之前，始终创建专用分支（或 worktree）
- **编码前先确认**：在实现开始前解决所有歧义
- **使用 TodoWrite**：全程跟踪所有进度

---

## 阶段一：解析参数并加载规格

初始参数：$ARGUMENTS

**操作**：
1. 解析参数：
   - 功能名称：第一个参数（例如：`user-auth`）
   - Worktree 模式：检测是否存在 `--worktree` 标志
2. 加载规格文档：读取 `.claude/specs/[功能名称].md`
3. 如果规格文档不存在：
   - 通知用户："在 `.claude/specs/[功能名称].md` 未找到规格文档"
   - 询问："是否先执行 `/spec [功能名称]` 来创建规格？"
   - 停止并等待用户决定
4. 为所有阶段创建 todo 列表
5. 向用户展示规格摘要：功能名称、需求数量、关键参与者

---

## 阶段二：创建分支或 Worktree

**目标**：在编写任何代码前隔离开发工作

**普通模式**（无 `--worktree` 标志）：
```bash
git checkout -b feature/[功能名称]
```

**Worktree 模式**（有 `--worktree` 标志）：
```bash
# 在同级目录创建带新分支的 worktree
git worktree add ../[功能名称] -b feature/[功能名称]
```
之后所有工作在 `../[功能名称]/` 目录中进行。

**操作**：
1. 执行上述对应的 git 命令
2. 更新规格文档 `.claude/specs/[功能名称].md`，在顶部添加开发元数据：
   ```markdown
   ## 开发信息
   - **分支**：feature/[功能名称]
   - **Worktree 路径**：../[功能名称]  ← （仅 --worktree 模式）
   - **开始时间**：[当前日期]
   - **状态**：进行中
   ```
3. 告知用户当前使用的模式以及创建的分支/worktree

---

## 阶段三：代码库探索

**目标**：在规划实现前了解现有代码库

**角色**：代码分析专家（Code Explorer）

**分析方法**：
1. **功能发现**：找到入口点（API、UI 组件、CLI 命令），定位核心实现文件，梳理功能边界和配置
2. **代码流程追踪**：从入口到输出追踪调用链，追踪每一步的数据转换，识别所有依赖和集成点
3. **架构分析**：映射抽象层（展示层 → 业务逻辑层 → 数据层），识别设计模式和架构决策
4. **实现细节**：关键算法、错误处理、边界情况、性能考量

**操作**：
1. 探索与 [功能名称] 相似的现有功能或模式
2. 完整追踪其从入口到输出的实现流程
3. 梳理整体架构，识别相关的关键抽象层和设计模式
4. 向用户呈现需要遵循的模式和规范摘要

---

## 阶段四：实现规划

**目标**：根据规格需求创建详细的任务计划，并保存为 task 文件

**角色**：实现规划专家（Dev Planner）

**工作流程**：
1. **读取并解析规格文档**：
   - 识别所有功能需求（FR-*）及其 EARS 语句
   - 记录所有非功能需求（NFR-*）
   - 列出所有依赖关系和约束条件
2. **探索代码库**：
   - 找出现有的类似功能模式
   - 识别技术栈、模块结构和代码规范
   - 定位需要修改的文件
   - 检查可复用的已有工具类、基类或抽象层
3. **将需求映射到实现**：
   - 确定需要创建或修改哪些文件
   - 确定需要添加哪些函数/类/组件
   - 确定与现有代码的集成点
   - 如何验证验收标准
4. **规划实现顺序**：
   - 从数据模型/类型开始
   - 然后是核心业务逻辑
   - 然后是 API/接口层
   - 然后是 UI/展示层
   - 最后是集成验证

**输出格式**（严格按照 `templates/task.md` 模板结构）：
- **实现思路**：整体策略和架构决策（1 段话）
- **需求映射**：每条 FR/NFR 与实现文件的对应表格
- **任务列表**：5 个阶段（数据模型 → 核心逻辑 → API 层 → UI 层 → 验证），每条任务标注文件路径和来源需求
- **关键文件**：新建文件表 + 修改文件表
- **潜在风险**：风险、影响级别、缓解措施表格
- **开放问题**：编码前需用户确认的未解决问题清单

**操作**：
1. 确定模板文件路径：使用插件内置模板 `${CLAUDE_PLUGIN_ROOT}/templates/task.md`。
2. 基于规格文档和代码库探索发现，生成详细的实现计划
3. 将生成的实现计划保存到 `.claude/tasks/[功能名称].md`：
   ```bash
   mkdir -p .claude/tasks
   ```
4. 审查计划，向用户展示：
   - 任务总数和阶段划分
   - 需要新建/修改的文件列表
   - 开放问题清单（将在阶段五确认）

---

## 阶段五：澄清问题

**目标**：编码前解决所有歧义

**重要**：如果存在待解决问题，不得跳过此阶段。

**操作**：
1. 审查规格需求和实现计划，找出所有缺口或歧义
2. 列出所有未解决的问题（边界情况、集成细节、设计偏好）
3. **向用户呈现问题列表并等待答复**
4. 如果用户说"用你认为最好的方式"，在继续前确认你的决策

---

## 阶段六：实现

**目标**：按照规格文档构建功能

**未经用户批准（阶段五问答结束后）不得开始实现**

**操作**：
1. 按阶段依次完成任务列表
2. **[关键安全断言]** 如果是 worktree 模式：
   - **在采取任何操作前，你必须先 `cd ../[功能名称]` 切换到该目录**。
   - 之后的所有命令行工具、文件读写（ls, grep, cat, 编辑器等）都必须基于该工作树内执行。
   - 绝对禁止在未切换目录前就修改主工作区的文件！
3. 对于每个子任务：
   - 先阅读相关现有文件（需遵循上述路径规则）
   - 遵循阶段三发现的代码库规范进行实现
   - 将实现追溯到规格需求
   - 完成每个任务后更新 todo

---

## 阶段七：总结

**目标**：记录完成情况

**操作**：
1. 标记所有 todo 为完成
2. 更新规格文档 `.claude/specs/[功能名称].md` 的开发元数据：
   - 状态：已完成
   - 完成日期
3. 总结：
   - 构建了什么、实现了哪些规格需求
   - 创建/修改的文件
   - 包含改动的分支（或 worktree 路径）
   - 下一步：执行 `/review` 对照规格审查代码
